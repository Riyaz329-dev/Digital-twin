# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1094agxezIJUsCqy8wH2d5pw4XewJv1E-
"""

# app.py
# Digital Twin Framework for Real-Time Diabetes Management
# -------------------------------------------------------
# Files expected in the same folder:
#  - best_model.pkl
#  - feature_cols.pkl
#  - decision_threshold.pkl
#  - Collected_cleaned.csv
#
# Run:
#   pip install streamlit pandas plotly scikit-learn xgboost joblib
#   streamlit run app.py
#
# Notes:
# - Uses a simulated "real-time" stream over your shifted timeline.
# - Pages: All Patients | Patient Twin | Model & Threshold | Data & Logs

import os
import time
import joblib
import numpy as np
import pandas as pd
from datetime import datetime

import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from sklearn.metrics import (
    accuracy_score, precision_score, recall_score,
    f1_score, roc_auc_score, confusion_matrix
)

# ---------- GLOBAL CONFIG ----------
st.set_page_config(
    page_title="Digital Twin: Real-Time Diabetes Management",
    page_icon="ü©∫",
    layout="wide",
)

# ---------- HELPERS: LOADERS & CACHE ----------
@st.cache_resource
def load_model_artifacts():
    model = joblib.load("best_model.pkl")
    feature_cols = joblib.load("feature_cols.pkl")
    threshold = joblib.load("decision_threshold.pkl")
    return model, feature_cols, float(threshold)

@st.cache_data
def load_collected() -> pd.DataFrame:
    """
    Expected columns in Collected_cleaned.csv:
      ['patient_id','timestamp','age','hypertension','heart_disease',
       'bmi','HbA1c_level','blood_glucose_level','diabetes',
       'gender_Male','gender_Other',
       'smoking_history_ever','smoking_history_never',
       'smoking_history_past','smoking_history_unknown']
    """
    df = pd.read_csv("Collected_cleaned.csv")
    # Ensure timestamp type
    if "timestamp" in df.columns:
        df["timestamp"] = pd.to_datetime(df["timestamp"], errors="coerce")
    else:
        raise ValueError("Collected_cleaned.csv must contain a 'timestamp' column.")
    # Build shifted timeline (so stream looks like this week)
    start_date_hist = df["timestamp"].dt.normalize().min()
    today_norm = pd.Timestamp.now().normalize()
    delta_to_today = today_norm - start_date_hist
    df["shifted_ts"] = df["timestamp"] + delta_to_today
    # Basic guards
    if "patient_id" not in df.columns:
        raise ValueError("Collected_cleaned.csv must contain 'patient_id'.")
    return df.sort_values(["patient_id", "shifted_ts"]).reset_index(drop=True)

def get_patient_list(df: pd.DataFrame):
    return sorted(df["patient_id"].astype(str).unique().tolist())

def advise(glucose: float, hba1c: float) -> str:
    if glucose < 140 and hba1c < 6:
        return "üü¢ Normal: Maintain healthy diet and regular exercise."
    elif 140 <= glucose < 180 or (6 <= hba1c < 7):
        return "‚ö†Ô∏è  Slightly elevated: Recheck in a few hours and limit sugar intake."
    elif glucose >= 180 or hba1c >= 7:
        return "üî¥ High: Monitor closely and consult your clinician if persistent."
    return "‚ÑπÔ∏è Unable to determine ‚Äî please verify readings."

def predict_row(model, feature_cols, row: pd.Series) -> float:
    x = pd.DataFrame([row[feature_cols].values], columns=feature_cols)
    proba = float(model.predict_proba(x)[0][1])
    return proba

def status_from_proba(proba: float, threshold: float) -> str:
    return "DIABETIC" if proba >= threshold else "NORMAL"

def color_from_status(status: str) -> str:
    return "#d62728" if status == "DIABETIC" else "#2ca02c"  # red / green

def compute_kpis(g: pd.DataFrame, threshold: float):
    # Time-in-range proxy (<180 mg/dL)
    tir = None
    if not g.empty:
        tir = float((g["blood_glucose_level"] < 180).mean() * 100.0)
    alerts = int((g.get("proba", pd.Series([])) >= threshold).sum()) if "proba" in g else 0
    mean_glucose = float(g["blood_glucose_level"].mean()) if not g.empty else np.nan
    max_prob = float(g.get("proba", pd.Series([0.0])).max()) if "proba" in g else np.nan
    return tir, alerts, mean_glucose, max_prob

def ensure_session():
    # Global session values
    if "autoplay" not in st.session_state:
        st.session_state.autoplay = False
    if "last_tick" not in st.session_state:
        st.session_state.last_tick = 0.0
    if "stream_index" not in st.session_state:
        st.session_state.stream_index = {}  # per-patient pointer
    if "log_df" not in st.session_state:
        st.session_state.log_df = pd.DataFrame(columns=[
            "patient_id","historical_ts","shifted_ts","arrival_ts",
            "shown_ts","blood_glucose_level","HbA1c_level",
            "proba","pred","status","advice"
        ])

def init_patient_pointer(pid: str, df: pd.DataFrame):
    if pid not in st.session_state.stream_index:
        st.session_state.stream_index[pid] = 0

def advance_one_tick(pid: str, df: pd.DataFrame, model, feature_cols, threshold: float):
    """
    Advance the stream for one patient by one row on shifted timeline.
    Append the prediction to session log (and optionally to disk).
    """
    g = df[df["patient_id"].astype(str) == str(pid)].sort_values("shifted_ts")
    if g.empty:
        return False

    i = st.session_state.stream_index.get(pid, 0)
    if i >= len(g):
        return False

    row = g.iloc[i]
    proba = predict_row(model, feature_cols, row)
    pred = 1 if proba >= threshold else 0
    status = "DIABETIC" if pred == 1 else "NORMAL"
    rec = {
        "patient_id": row["patient_id"],
        "historical_ts": row["timestamp"],
        "shifted_ts": row["shifted_ts"],
        "arrival_ts": pd.Timestamp.now(),
        "shown_ts": row["shifted_ts"],
        "blood_glucose_level": float(row["blood_glucose_level"]),
        "HbA1c_level": float(row["HbA1c_level"]),
        "proba": proba,
        "pred": pred,
        "status": status,
        "advice": advise(float(row["blood_glucose_level"]), float(row["HbA1c_level"]))
    }
    st.session_state.log_df = pd.concat([st.session_state.log_df, pd.DataFrame([rec])], ignore_index=True)
    st.session_state.stream_index[pid] = i + 1
    # Also append to disk log
    try:
        append_to_csv("live_predictions_log.csv", pd.DataFrame([rec]))
    except Exception:
        pass
    return True

def append_to_csv(path: str, df_new: pd.DataFrame):
    header = not os.path.exists(path)
    df_new.to_csv(path, mode="a", header=header, index=False)

def plot_patient_trend(df_show: pd.DataFrame, threshold: float, title: str):
    if df_show.empty:
        st.info("No data yet to plot.")
        return

    colors = df_show["status"].map(lambda s: "#d62728" if s == "DIABETIC" else "#2ca02c")
    fig = go.Figure()
    # Line for glucose
    fig.add_trace(go.Scatter(
        x=df_show["shown_ts"], y=df_show["blood_glucose_level"],
        mode="lines+markers",
        marker=dict(size=8, color=colors, line=dict(width=1, color="black")),
        line=dict(width=2),
        name="Glucose (mg/dL)"
    ))
    # In-range band 70-180
    fig.add_hrect(y0=70, y1=180, fillcolor="rgba(0,200,0,0.05)", line_width=0, annotation_text="70‚Äì180 mg/dL")
    # 180 threshold line
    fig.add_hline(y=180, line_dash="dash", line_color="orange", annotation_text="180 mg/dL")

    fig.update_layout(
        title=title,
        xaxis_title="Time",
        yaxis_title="Blood Glucose (mg/dL)",
        height=420,
        margin=dict(l=20, r=20, t=40, b=20)
    )
    st.plotly_chart(fig, use_container_width=True)

def cohort_tiles(df_log: pd.DataFrame, pids: list, threshold: float):
    cols = st.columns(5)
    for idx, pid in enumerate(pids):
        g = df_log[df_log["patient_id"].astype(str) == str(pid)]
        if g.empty:
            status = "‚Äî"
            prob = "‚Äî"
            last_g = "‚Äî"
            dot = "‚ö™"
            t = "‚Äî"
        else:
            last = g.sort_values("shown_ts").iloc[-1]
            status = last["status"]
            prob = f"{last['proba']:.2f}"
            last_g = int(last["blood_glucose_level"])
            dot = "üü¢" if status == "NORMAL" else "üî¥"
            t = pd.to_datetime(last["shown_ts"]).strftime("%d %b %H:%M")

        with cols[idx % 5]:
            st.metric(label=f"{dot} Patient {pid}", value=f"Status: {status}", delta=f"Prob: {prob}")
            st.caption(f"Last: {last_g} mg/dL ‚Ä¢ {t}")

# ---------- PAGES ----------
def page_all_patients(df, model, feature_cols, threshold):
    st.markdown("## üè• All Patients ‚Äî Command Center")
    pids = get_patient_list(df)

    # Controls
    with st.sidebar:
        st.markdown("### ‚ñ∂Ô∏è Stream Controls")
        autoplay = st.toggle("Auto-play stream (selected patient)", value=st.session_state.autoplay)
        st.session_state.autoplay = autoplay
        refresh = st.slider("Auto-play interval (seconds)", 0.5, 3.0, 1.0, 0.5)
        target_pid = st.selectbox("Select patient to stream", pids, index=0)
        init_patient_pointer(target_pid, df)
        col_a, col_b = st.columns(2)
        if col_a.button("Advance one tick"):
            advance_one_tick(target_pid, df, model, feature_cols, threshold)
            st.rerun()
        if col_b.button("Reset patient stream"):
            st.session_state.stream_index[target_pid] = 0
            st.session_state.log_df = st.session_state.log_df[st.session_state.log_df["patient_id"] != target_pid]
            st.rerun()

    # Autoplay loop (1 step per refresh interval)
    now = time.time()
    if st.session_state.autoplay and now - st.session_state.last_tick >= refresh:
        did = advance_one_tick(target_pid, df, model, feature_cols, threshold)
        st.session_state.last_tick = now
        if did:
            st.rerun()

    # KPI row (cohort)
    st.markdown("#### Cohort Overview")
    log = st.session_state.log_df.copy()
    cohort_tiles(log, pids, threshold)

    # Alerts table (latest 50)
    st.markdown("#### Recent Alerts")
    if log.empty:
        st.info("No alerts yet. Start streaming.")
    else:
        alerts = log[log["proba"] >= threshold].sort_values("shown_ts", ascending=False).head(50)
        st.dataframe(
            alerts[["patient_id","shown_ts","blood_glucose_level","HbA1c_level","proba","status","advice"]]
            .rename(columns={
                "blood_glucose_level":"glucose",
                "HbA1c_level":"hba1c"
            }),
            use_container_width=True,
            hide_index=True
        )

def page_patient_twin(df, model, feature_cols, threshold):
    st.markdown("## üë§ Patient Twin ‚Äî Real-Time Cockpit")

    pids = get_patient_list(df)
    with st.sidebar:
        pid = st.selectbox("Patient", pids, index=0)
        init_patient_pointer(pid, df)
        st.markdown("---")
        st.markdown("### ‚ñ∂Ô∏è Live Stream")
        autoplay = st.toggle("Auto-play (this patient)", value=st.session_state.autoplay, key="autoplay_pt")
        st.session_state.autoplay = autoplay
        refresh = st.slider("Interval (seconds)", 0.5, 3.0, 1.0, 0.5, key="refresh_pt")
        col_a, col_b = st.columns(2)
        if col_a.button("Next tick", key="next_tick_pt"):
            advance_one_tick(pid, df, model, feature_cols, threshold)
            st.rerun()
        if col_b.button("Reset stream", key="reset_tick_pt"):
            st.session_state.stream_index[pid] = 0
            st.session_state.log_df = st.session_state.log_df[st.session_state.log_df["patient_id"] != pid]
            st.rerun()
        st.markdown("---")
        st.markdown("### Threshold")
        st.caption("Current decision threshold used for status.")
        st.info(f"Threshold: **{threshold:.3f}** (edit in *Model & Threshold* page)")

    # Autoplay step
    now = time.time()
    if st.session_state.autoplay and now - st.session_state.last_tick >= refresh:
        did = advance_one_tick(pid, df, model, feature_cols, threshold)
        st.session_state.last_tick = now
        if did:
            st.rerun()

    # Current log slice for patient
    log = st.session_state.log_df.copy()
    g = log[log["patient_id"].astype(str) == str(pid)].sort_values("shown_ts")

    # Header cards: current twin state
    c1, c2, c3, c4 = st.columns(4)
    if g.empty:
        c1.metric("Latest Glucose", "‚Äî")
        c2.metric("Latest HbA1c", "‚Äî")
        c3.metric("Risk Probability", "‚Äî")
        c4.metric("Status", "‚Äî")
    else:
        last = g.iloc[-1]
        c1.metric("Latest Glucose", f"{int(last['blood_glucose_level'])} mg/dL")
        c2.metric("Latest HbA1c", f"{float(last['HbA1c_level']):.2f}")
        c3.metric("Risk Probability", f"{float(last['proba']):.3f}")
        c4.metric("Status", last["status"], help=last["advice"])

    # Trend chart
    plot_patient_trend(g, threshold, f"Patient {pid} ‚Äî Glucose trend (green=NORMAL, red=DIABETIC)")

    # KPIs + Advice + Events
    k1, k2, k3, k4 = st.columns(4)
    tir, alerts, mean_glucose, max_prob = compute_kpis(g, threshold)
    k1.metric("Time-in-Range (70‚Äì180) %", f"{0 if tir is None else tir:.1f}%")
    k2.metric("Alerts in Window", f"{alerts}")
    k3.metric("Mean Glucose", "‚Äî" if np.isnan(mean_glucose) else f"{mean_glucose:.0f} mg/dL")
    k4.metric("Max Probability", "‚Äî" if np.isnan(max_prob) else f"{max_prob:.2f}")

    st.markdown("#### Advice Feed")
    if g.empty:
        st.info("No events yet. Start streaming.")
    else:
        show = g[["shown_ts","blood_glucose_level","HbA1c_level","status","advice","proba"]].tail(10)
        show = show.rename(columns={
            "shown_ts":"time",
            "blood_glucose_level":"glucose",
            "HbA1c_level":"hba1c"
        })
        st.dataframe(show, use_container_width=True, hide_index=True)

    st.caption("‚ö†Ô∏è This app provides educational decision support. It is not a substitute for professional medical advice.")

def page_model_threshold(df, model, feature_cols, threshold):
    st.markdown("## üß† Model & Threshold ‚Äî Twin Brain")

    st.markdown("### Global Feature Importance")
    # Try to read feature importances if available
    try:
        importances = getattr(model, "feature_importances_", None)
        if importances is not None:
            fi = pd.DataFrame({"feature": feature_cols, "importance": importances})
            fi = fi.sort_values("importance", ascending=False).head(15)
            fig = px.bar(fi, x="importance", y="feature", orientation="h", title="Top Features")
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.info("Model does not expose `feature_importances_`.")
    except Exception as e:
        st.warning(f"Could not compute feature importance: {e}")

    st.markdown("### Threshold Tuning ‚Äî Preview on Collected Data")
    st.caption("Adjust decision threshold to see precision/recall trade-offs on your collected dataset.")
    new_thr = st.slider("Threshold", 0.05, 0.95, float(threshold), 0.01)

    # Evaluate on collected data (has labels)
    try:
        # Build X, y from collected using the same feature columns
        df_eval = df.dropna(subset=feature_cols + ["diabetes"]).copy()
        X_eval = df_eval[feature_cols]
        y_eval = df_eval["diabetes"].astype(int)
        # Predict probabilities
        proba_eval = model.predict_proba(X_eval)[:, 1]
        y_pred_eval = (proba_eval >= new_thr).astype(int)

        acc  = accuracy_score(y_eval, y_pred_eval)
        prec = precision_score(y_eval, y_pred_eval, zero_division=0)
        rec  = recall_score(y_eval, y_pred_eval, zero_division=0)
        f1   = f1_score(y_eval, y_pred_eval, zero_division=0)
        try:
            auc  = roc_auc_score(y_eval, proba_eval)
        except Exception:
            auc = float("nan")

        c1, c2, c3, c4, c5 = st.columns(5)
        c1.metric("Accuracy", f"{acc:.3f}")
        c2.metric("Precision", f"{prec:.3f}")
        c3.metric("Recall", f"{rec:.3f}")
        c4.metric("F1-score", f"{f1:.3f}")
        c5.metric("ROC-AUC", f"{auc:.3f}" if not np.isnan(auc) else "‚Äî")

        with st.expander("Confusion Matrix"):
            cm = confusion_matrix(y_eval, y_pred_eval)
            st.write(pd.DataFrame(cm,
                                  index=["Actual 0 (non-diabetic)", "Actual 1 (diabetic)"],
                                  columns=["Pred 0", "Pred 1"]))
    except Exception as e:
        st.warning(f"Could not evaluate on collected data: {e}")

    # Save threshold button
    if st.button("üíæ Save this threshold"):
        try:
            joblib.dump(float(new_thr), "decision_threshold.pkl")
            st.success(f"Saved threshold = {new_thr:.3f}. Reload the app to use it.")
        except Exception as e:
            st.error(f"Failed to save threshold: {e}")

def page_data_logs():
    st.markdown("## üìú Data & Logs ‚Äî Twin Memory")
    st.caption("Live predictions are appended to `live_predictions_log.csv` as the stream progresses.")

    # Preview in-session log
    st.markdown("### In-session Log (latest 200)")
    if st.session_state.log_df.empty:
        st.info("No log yet in this session.")
    else:
        st.dataframe(st.session_state.log_df.sort_values("shown_ts").tail(200), use_container_width=True, hide_index=True)

    # Disk log
    st.markdown("### On-Disk Log")
    if os.path.exists("live_predictions_log.csv"):
        try:
            disk = pd.read_csv("live_predictions_log.csv", parse_dates=["historical_ts","shifted_ts","arrival_ts","shown_ts"])
            st.dataframe(disk.tail(200), use_container_width=True, hide_index=True)
            st.download_button("‚¨áÔ∏è Download full log CSV", data=disk.to_csv(index=False), file_name="live_predictions_log.csv", mime="text/csv")
        except Exception as e:
            st.warning(f"Could not read on-disk log: {e}")
    else:
        st.info("`live_predictions_log.csv` not found yet. Start streaming to create it.")

    # Clear disk log (optional)
    if st.button("üóëÔ∏è Clear on-disk log"):
        try:
            if os.path.exists("live_predictions_log.csv"):
                os.remove("live_predictions_log.csv")
            st.success("Cleared `live_predictions_log.csv`.")
        except Exception as e:
            st.error(f"Failed to clear: {e}")

# ---------- MAIN ----------
def main():
    st.title("ü©∫ Digital Twin Framework ‚Äî Real-Time Diabetes Management")
    st.caption("Prototype for educational decision support ‚Äî not for medical use.")

    ensure_session()

    # Load artifacts and data
    try:
        model, feature_cols, threshold = load_model_artifacts()
    except Exception as e:
        st.error(f"Error loading model artifacts: {e}")
        st.stop()

    try:
        df = load_collected()
    except Exception as e:
        st.error(f"Error loading collected data: {e}")
        st.stop()

    # Sidebar navigation
    st.sidebar.markdown("## Navigation")
    page = st.sidebar.radio(
        "Go to",
        ["All Patients", "Patient Twin", "Model & Threshold", "Data & Logs"],
        index=0
    )

    if page == "All Patients":
        page_all_patients(df, model, feature_cols, threshold)
    elif page == "Patient Twin":
        page_patient_twin(df, model, feature_cols, threshold)
    elif page == "Model & Threshold":
        page_model_threshold(df, model, feature_cols, threshold)
    else:
        page_data_logs()

if __name__ == "__main__":
    main()

